# 📘 『도메인 주도 개발 시작하기』 - Chapter 7~9 요약 및 정리

도메인 주도 설계(DDD)를 학습하면서 정리한 내용입니다.

개념 위주 요약보다는, 실무에서 느낀 점과 함께 정리했습니다.

---

## 📑 목차

[Chapter 7. 도메인 서비스](#chapter-7-도메인-서비스)

[Chapter 8. 애그리거트와 트랜잭션 관리](#Chapter-8-애그리거트와-트랜잭션-관리)

[Chapter 9. 도메인 모델과 바운디드 컨텍스트](#Chapter-9-도메인-모델과-바운디드-컨텍스트)

---

## Chapter 7. 도메인 서비스

### 💬 간단 정리

- 도메인 로직은 기본적으로 애그리거트에 작성하게 된다. 하지만 여러 애그리거트가 필요한 기능이라면 도메인 서비스에 도메인 로직을 작성하게 된다.
    - 주로 `계산 로직`과 `외부 시스템 연동이 필요한 도메인 로직`에 도메인 서비스가 많이 이용된다.
    - 애그리거트/밸류와 도메인 서비스의 로직의 차이
        - 도메인 서비스의 로직은 상태 없이 로직만 구현한다는 점이 애그리거트/밸류와 다르다.
- 도메인 서비스를 사용하는 주체
    - 응용 서비스: 도메인 서비스 내부에서 애그리거트/밸류의 도메인 로직을 실행하는 역할 수행
    - 애그리거트: 도메인 서비스를 파라미터로 애그리거트 내부에서 도메인 서비스 호출
    `agg.doAnything(domainService)`
        - 책 글쓴이는 애그리거트에 파라미터로 의존하는 것을 추천한다. 이외의 방법으로는 Spring의 DI를 이용한 필드 주입이 있는데, 다음 이유로 인해 추천하지 않는다.
            1. 애그리거트 내부의 도메인서비스 필드는 데이터가 아니다.
            2. 애그리거트 내부의 도메인서비스 필드는 저장 대상이 아니다.
            3. 애그리거트 내부의 도메인서비스 필드는 모든 기능에서 필요한 것이 아닌 일부 기능에서만 필요하다.
- 도메인 서비스 vs 응용 서비스
    - 도메인 서비스에서 처리할 것: 애그리거트의 상태 변경 및 상태 값 계산 (e.g. 계좌 이체 로직, 주문 결제 금액 계산 로직)
    - 응용 서비스에서 처리할 것: 트랜잭션, 이벤트 처리 등등
    - 도메인 서비스에서 트랙잭션을 처리하지 않는다.
- 외부 시스템 연동을 하는 도메인 서비스에서는 도메인 로직 관점에서의 인터페이스를 작성하고 외부 서비스에 맞게 구현체를 작성한다.
    - return 값, 메서드 이름, 파라미터를 내부 시스템 및 도메인 로직 관점에서 작성하여 외부 서비스가 변경되더라도 문제 없게 구현한다.

### 💡 관련 생각

- 도메인 서비스에서 트랜잭션 처리를 안한다는 것에 대해 다시 생각해보게 되었다. 트랜잭션을 너무 남발하여 기능 단위로 트랜잭션을 설정하는 것이 아닌 세부 도메인 로직 단위로 트랜잭션을 설정하는 것이 아닌지 다시 돌아보게 되었다.
- 도메인 서비스라는 개념 자체가 생소했는데, 여러 도메인 객체를 사용할 때 작성한다는 것을 보고 자주 쓰는 것이어서 익숙하게 느껴졌다. 다만, 기존에는 도메인 서비스를 사용해도 되는 기준이 애매했는데 조금 구체적으로 변하게 되었다.

---

## Chapter 8. 애그리거트와 트랜잭션 관리

### 💬 간단 정리

- 다른 쓰레드에서 같은 애그리거트를 수정할 때는 동시성 이슈가 발생할 수 있으므로 트랜잭션 처리가 필요하다.
    - 트랜잭션 처리에는 크게 2가지가 있다. 선점 잠금(비관점 락)/비선점 잠금(낙관적 락)
- 선점 잠금: 먼저 애그리거트를 구한 쓰레드가 애그리거트의 사용이 끝날 때까지 다른 쓰레드가 해당 애그리거트를 수정하지 못하게 막는 방식
    - 스프링 데이터 JPA에서는 `@Lock(LockModeType.PESSIMISTIC_WRITE)`를 이용하여 적용
    - 교착 상태를 방지하기 위해 최대 대기 시간을 설정할 수 있다. `@QueryHints(name = “javax.persistence.lock.timeout”, value = “2000”)`
- 비선점 잠금: 변경한 데이터를 실제 DBMS에 반영하는 시점에 변경 가능 여부를 확인하는 방식
    - 조회할 때의 버전과 업데이트할 때의 버전을 비교하여 일치하면 반영한다.
    - `@Version`을 컬럼에 명시하여 설정할 수 있다.
    - 보통 애그리거트 루트 외에 밸류 값이 변할 경우 JPA에서는 애그리거트의 버전을 업데이트하지 않는다.
        - 이것을 강제로 하기 위해 `@Lock(LockModeType.OPTIMISTIC_FORCE_INCREMENT)` 로 설정할 수 있다.
- 오프라인 선점 잠금
    - 단일 트랜잭션에서의 동시 접근을 막는 이전 잠금들과 달리 여러 트랜잭션에 걸쳐 동시 접근을 막는 기법이다.
    - 조회 트랜잭션에서 Lock을 획득하여, DB 등 저장소에 저장하고, 수정할 때 Lock의 유효성을 판단하여 수정한다.

### 💡 관련 생각

- 오프라인 선점 잠금은 여러 서버를 거쳐 실행되는 기능에 대해 유용하다는 생각이 들었다.

---

## Chapter 9. 도메인 모델과 바운디드 컨텍스트

### 💬 간단 정리

- 도메인 모델은 컨텍스트 마다 다른 의미를 지닐 수 있다. 도메인 모델의 의미를 구분짓는 컨텍스트를 **바운디드 컨텍스트**라고 한다.
- 바운디드 컨텍스트마다 같은 도메인 모델이라도 다른 객체로 표현될 수 있다.
    - 클래스 이름이 달라질 수도 있고, 내부 연관관계가 달라질 수도 있다.
- 바운디드 컨텍스트 내부 구현은 팀 상황에 맞게 자유롭게 변형될 수 있다.
    - 내부 구조를 도메인 주도로 갈 수도 있고, 서비스-DAO 구조로 개발될 수도 있다.
- 바운디드 컨텍스트 간의 통합은 크게 2가지이다.
    - 직접 통합(REST API 등)
    - 간접 통합(메시지 큐 등)

### 💡 관련 생각

- 바운디드 컨텍스트마다 도메인 모델을 다르게 구성할 수 있는 점에서 각 모델마다 다른 도메인 로직을 적용시킬 수 있지 않을까 하는 생각이 들었다.
    - 한 도메인 모델로 다른 컨텍스트를 모두 커버하도록 개발하면 내부에 여러 종류의 도메인 로직이 섞이니 분리하는 것이 유지보수하기 좋겠다는 생각이 들었다.

---

📚 계속해서 7~9장 정리도 이어질 예정입니다.

피드백이나 질문은 댓글로 남겨주세요!
