<!-- TOC -->
* [6.1 표현 영역과 응용 영역](#61-표현-영역과-응용-영역)
* [6.2 응용 서비스의 역할](#62-응용-서비스의-역할)
  * [6.2.1 도메인 로직 넣지 않기](#621-도메인-로직-넣지-않기)
  * [6.3 응용 서비스의 구현](#63-응용-서비스의-구현)
  * [6.3.1 응용 서비스의 크기](#631-응용-서비스의-크기)
    * [하나의 응용 서비스 Vs. 기능별 응용 서비스](#하나의-응용-서비스-vs-기능별-응용-서비스)
    * [하나의 응용 서비스](#하나의-응용-서비스)
    * [구분되는 기능별로 서비스 클래스](#구분되는-기능별로-서비스-클래스)
    * [헬퍼 클래스: 각 응용 서비스에서 공통되는 로직을 별도 클래스로 구현](#헬퍼-클래스-각-응용-서비스에서-공통되는-로직을-별도-클래스로-구현)
  * [6.3.2 응용 서비스의 인터페이스와 클래스](#632-응용-서비스의-인터페이스와-클래스)
  * [6.3.3 메서드 파라미터와 값 리턴](#633-메서드-파라미터와-값-리턴)
  * [6.3.4 표현 영역에 의존하지 않기](#634-표현-영역에-의존하지-않기)
  * [6.3.5 트랜잭션 처리](#635-트랜잭션-처리)
  * [6.4 표현 영역](#64-표현-영역)
  * [6.5 값 검증](#65-값-검증)
    * [구현의 편리함을 위한 역할 분리](#구현의-편리함을-위한-역할-분리)
    * [범균님은 응용에서 값 검증한다.](#범균님은-응용에서-값-검증한다)
  * [6.6 권한 검사](#66-권한-검사)
    * [개별 도메인 객체 단위로 권한 검사해야하는 경우](#개별-도메인-객체-단위로-권한-검사해야하는-경우)
    * [프레임워크 이해도가 낮다면 개별 도메인 권한 검사는 직접 구현](#프레임워크-이해도가-낮다면-개별-도메인-권한-검사는-직접-구현)
  * [6.7 조회 전용 기능과 응용 서비스](#67-조회-전용-기능과-응용-서비스)
<!-- TOC -->

# 6.1 표현 영역과 응용 영역

- 표현 영역:
  - 사용자 요청 해석
- 응용 영역:
  - 실제 사용자가 원하는 기능을 제공하는 것은 응용 영역에 위치한 서비스.

# 6.2 응용 서비스의 역할

- 주요 역할: 도메인 객체를 사용해서 사용자의 요청을 처리
  - 사용자의 요청을 처리하기 위해, 리포지터리에서 도메인 객체를 가져와 사용.
  - 응용 서비스가 복잡? -> 도메인 로직의 일부를 구현하고 있을 가능성이 높다.
- 부가역할
  - **트랜잭션 처리**
  - **접근 제어**
  - **이벤트 처리**


## 6.2.1 도메인 로직 넣지 않기

- 사용자의 암호를 바꾸는 로직에서, 
  - 기존 암호를 올바르게 입력해슨지 확인하는 것은 도메인 핵심 로직
- 다음 같이 응용 서비스에서 위 로직을 구현하면 안 된다

```java
ChangePasswordService {
  
  void changePasswrod(memberId, oldPw, newPw) {
    var member = memberRepository.findById(memberId)
      
     if (!passwordEncoder.matches(oldPw, member.pw)) {
      throw BadPwEx
    }
     
    member.setPw(newPw)
  }
}
```

- 도메인 로직은 도메인 영역에 모아서 코드 중복을 줄이고 응집도를 높여야한다.

## 6.3 응용 서비스의 구현

## 6.3.1 응용 서비스의 크기

- 회원 도메인의 응용 서비스
  - 회원 가입
  - 회원 탈퇴
  - 회원 암호 변경
  - 비밀번호 초기화 

### 하나의 응용 서비스 Vs. 기능별 응용 서비스

- 한 응용 서비스 클래스에 회원 도메인의 모든 기능 구현
- 구분되는 기능별로 응용 서비스 클래스를 따로 구현

### 하나의 응용 서비스

- 코드의 크기가 커질 수록 연관성 적은 코드가 한 클래스에 위치할 가능성 높아짐.
  - 결과적으로 관련 없는 코드가 뒤섞여 이해하는데 방해됨.
- 코드가 모이기 시작하면 습관적으로 기존 클래스에 기능 억지로 끼워넣게됨. 결과적으로 코드 얽히게 되고 코드 품질 낮아짐.

### 구분되는 기능별로 서비스 클래스

- 한 응용 서비스 ㅋ틀래스에서 한 개 내지 2~3개 기능 구현.

### 헬퍼 클래스: 각 응용 서비스에서 공통되는 로직을 별도 클래스로 구현

- 예를 들면, id로 엔티티를 조회하는 로직.


## 6.3.2 응용 서비스의 인터페이스와 클래스

## 6.3.3 메서드 파라미터와 값 리턴

## 6.3.4 표현 영역에 의존하지 않기

- 응용 서비스 메서드 파라미터로 HttpServletRequest, HttpSession 등을 전달해서는 안 된다.
- 왜? 응용 서비스만으로 단독 테스트하기 어려워진다.
- 왜? 표현 영역의 구현이 변경되면 응용 서비스 구현도 함께 변경해야한다.
- 제일 심각한 문제: 응용이 표현의 역할을 대신 해버릴 수도..

## 6.3.5 트랜잭션 처리

```java
ChangePasswordService {

  @Transactional
  void changePassword(...) {
    var member = memberRepository.findById(memberId)
    member.changePassword
  }
}
```

## 6.4 표현 영역

역할 
1. 사용자 요청을 응용 서비스가 요구하는 형식으로 변환
2. 사용자 연결 상태인 세션 관리. (쿠키, 서버 세션 ..)

## 6.5 값 검증

- 표현, 응용 둘 다 가능
- 원칙적으로 응용에서 수행.
- 단, 응용에서 하면 사용자 경험 좋지 않아서 에러를 리스트로 모아서 리턴하기도 함.

### 구현의 편리함을 위한 역할 분리

- 표현: 필수값, 값의 형식, 범위 등 검증
- 데이터의 존재 유무와 같은 논리적 오류 검증.

### 범균님은 응용에서 값 검증한다.

- 응용 서비스에서 필요한 값 검증을 모두 처리하면 프레임워크에서 지원하는 검증 기능을 사용할 때 보다 코드는 증가.
- 그러나 응용 서비스의 완성도가 높아지고, 이것에대한 이점이 더 크게 느껴진다.


## 6.6 권한 검사

- 보통 서블릿 필터에서 인증 처리.

### 개별 도메인 객체 단위로 권한 검사해야하는 경우

- 게시글 삭제를 본인 또는 관리자만 가능하다고 할 경우, 
  - 게시글 작성자가 본인인지 확인하려면 게시글 애그리거트로딩 필요.

```java
public class DeleteArticleService {
  public void delete(String userId, Long articleId) {
    var article = articleRepo.findById(articleId)
    permissionService.checkeDeletePermision(userId, article)
    article.markDeleted()  
  }
}
```

### 프레임워크 이해도가 낮다면 개별 도메인 권한 검사는 직접 구현

- 스프링 시큐리티와 같은 프레임워크를 확장해서 개별 도메인 권한 검사 기능을 프레임워크에 통합 가능
  - 단, 높은 이해도 필요.
- 이해도가 높지 않다면, 도메인에 맞는 권한 검사 기능을 직접 구현하는 것이 코드 유지보수에 유리.


## 6.7 조회 전용 기능과 응용 서비스

- 조회 전용 기능을 만들 때는 응용 서비스 없이 사용 가능.
- 컨트롤러가 DAO 같은 조회 전용 기능을 바로 사용해도 문제 없다.
  - 응용 서비스가 사용자 요청 기능을 실행하는데 별다른 기여를 못한다면 굳이 서비스를 만들지 않아도 된다.