#### 1. 엔티티와 밸류의 기본 매핑

* **애그리거트 루트(Aggregate Root):** 애그리거트의 진입점 역할을 하는 엔티티로, `@Entity`로 매핑합니다.
* **밸류(Value):** 밸류 객체는 식별자를 가지지 않으며, 불변(immutable) 객체로 설계됩니다. 엔티티와 같은 테이블에 데이터를 저장하는 경우, 다음과 같이 매핑합니다.
    * **밸류 타입 클래스:** `@Embeddable` 어노테이션을 사용합니다.
    * **엔티티 내의 밸류 프로퍼티:** `@Embedded` 어노테이션을 사용합니다.
* **`AttributeConverter`:** 도메인 모델의 밸류 타입을 데이터베이스 컬럼 타입으로 변환하는 인터페이스입니다. `@Converter` 어노테이션을 적용하여 사용합니다.

#### 2. 밸류 컬렉션 매핑

* **별도 테이블 매핑:** `@ElementCollection`과 `@CollectionTable`을 함께 사용하여 밸류 객체 목록을 별도의 테이블에 저장할 수 있습니다.
* **단일 컬럼 매핑:** `Set<String>`과 같은 밸류 컬렉션을 DB의 콤마(`,`)로 구분된 단일 문자열 컬럼에 저장해야 할 때가 있습니다. 이 경우 `AttributeConverter`를 활용하여 밸류 컬렉션을 나타내는 새로운 밸류 타입을 추가하고, 해당 타입을 변환하는 컨버터를 구현하여 매핑할 수 있습니다.

#### 3. 밸류를 이용한 ID 매핑

* 식별자의 의미를 명확히 하기 위해 밸류 타입을 식별자로 사용할 수 있습니다.
* 이 경우 `@Id` 대신 `@EmbeddedId` 어노테이션을 사용합니다.
* **장점:** 식별자 밸류 타입에 식별자와 관련된 비즈니스 로직(예: 시스템 세대 구분 기능)을 추가할 수 있습니다.

#### 4. `clear()` 메서드의 주의사항

* **`@Entity` 컬렉션:** `@OneToMany` 관계로 매핑된 `@Entity` 컬렉션의 `clear()` 메서드를 호출하면, 하이버네이트는 비효율적인 삭제 과정을 수행합니다.
    * 먼저 `select` 쿼리로 모든 하위 엔티티를 로딩합니다.
    * 로딩된 각각의 엔티티에 대해 `delete` 쿼리를 개별적으로 실행합니다.
    * 변경 빈도가 높은 경우 전체 서비스 성능에 심각한 영향을 줄 수 있습니다.
* **`@Embeddable` 컬렉션:** `@Embeddable` 타입에 대한 컬렉션의 `clear()` 메서드는 객체를 로딩하지 않고 한 번의 `delete` 쿼리로 삭제를 처리합니다. 이는 `@Entity` 컬렉션에 비해 훨씬 효율적입니다.
* **해결 방안:** `@Entity` 컬렉션의 비효율적인 삭제 문제를 해결하기 위해, 상속 대신 `@Embeddable`로 매핑된 단일 클래스로 구현을 고려할 수 있습니다.

#### 5. 애그리거트의 영속성

* **완전한 상태:** 애그리거트는 개념적으로 하나이므로, 조회, 저장, 삭제 시 하나로 처리되어야 합니다. 하지만 루트 엔티티를 로딩할 때 모든 애그리거트 구성요소를 한꺼번에 로딩할 필요는 없습니다.
    * **지연 로딩(Lazy Loading):** 상태 변경 기능은 조회 기능보다 실행 빈도가 낮기 때문에, 지연 로딩으로 인한 추가 쿼리 발생은 일반적으로 성능 저하의 문제가 되지 않습니다.
* **영속성 전파(Persistence Propagation):**
    * `@Embeddable` 매핑 타입은 엔티티와 생명주기를 같이하므로, 별도의 `cascade` 속성 설정 없이 함께 저장되고 삭제됩니다.
    * 따라서 애그리거트 루트를 저장하거나 삭제할 때, 그에 속한 `Embeddable` 밸류 객체들은 자동으로 함께 처리됩니다.
