# 도메인 모델과 DIP

도메인 모델은 **도메인의 핵심 로직**을 구현한다.

예를 들어, 주문 도메인은 **배송지 변경**, **결제 완료**, **주문 총액 계산**과 같은 핵심 로직을 도메인 모델에서 구현한다.

---

## 도메인 모델과 인프라스트럭처 의존성

인프라스트럭처에 의존할 경우 두 가지 문제가 발생한다:

- **테스트의 어려움**
- **기능 확장의 어려움**

이 두 가지 문제를 해소할 수 있는 해답이 바로 **DIP(Dependency Inversion Principle, 의존 역전 원칙)** 이다.

---

## DIP란 무엇인가?

DIP를 적용하면 **저수준 모듈이 고수준 모듈에 의존**하게 된다.  
즉, 고수준 모듈이 저수준 모듈을 사용하더라도, 고수준 모듈이 직접 저수준 모듈에 의존하지 않도록 한다. 반대로 저수준 모듈이 고수준 모듈에 의존하도록 만드는 것이 DIP이다.

> DIP는 단순히 “인터페이스와 구현 클래스를 분리한다” 정도로 오해하기 쉽지만, 핵심은 **고수준 모듈이 저수준 모듈에 의존하지 않도록 설계하는 것**이다.

스프링과 같은 **의존 주입(Dependency Injection)** 을 지원하는 프레임워크를 사용하면 설정만으로 구현체를 쉽게 교체할 수 있다.

---

## DIP 적용의 유연함

DIP를 무조건 적용할 필요는 없다.  
구현 기술이나 상황에 따라 완벽하게 DIP를 적용하기보다는, **구현 기술에 의존적인 코드를 도메인에 일부 포함하는 편이 효과적**일 때도 있다.

또한 추상화 대상이 명확하지 않은 경우도 많다. 이럴 때는 무리해서 DIP를 적용하기보다는, **DIP의 이점을 얻는 수준에서 적용 범위**를 검토해보자.

---

## 도메인 모델 구성 요소

### 엔티티(Entity)

- **고유의 식별자**를 갖는 객체로, 자신의 라이프사이클을 관리한다.
- 예) 주문, 회원, 상품 등

---

### 밸류(Value)

- **고유 식별자를 갖지 않는 객체**로, 개념적으로 하나인 값을 표현할 때 사용된다.
- 예) 배송지 주소, 구매 금액
- 엔티티의 속성으로 사용되거나, 다른 밸류 타입의 속성으로도 활용된다.

---

### 애그리거트(Aggregate)

- 연관된 엔티티와 밸류 객체를 **개념적으로 하나로 묶은 것**이다.
- 군집에 속한 객체를 관리하는 **루트 엔티티(Aggregate Root)** 가 존재하며, 루트 엔티티가 애그리거트의 기능을 제공한다.

---

### 리포지토리(Repository)

- 도메인 모델의 **영속성**을 처리한다.

---

### 도메인 서비스(Domain Service)

- 특정 엔티티에 속하지 않는 도메인 로직을 제공한다.
- 예) **할인 금액 계산**  
  상품, 쿠폰, 회원 등급, 구매 금액 등 다양한 조건을 고려해야 하는 로직은 여러 엔티티와 밸류를 필요로 하므로, 도메인 서비스에서 구현한다.

---

## 도메인 모델 엔티티 vs 관계형 DB 엔티티

도메인 모델의 엔티티와 관계형 DB의 엔티티는 같은 것이 아니다.

가장 큰 차이점은, 도메인 모델의 엔티티는 **데이터뿐 아니라 도메인 기능을 함께 제공한다**는 점이다.

```java
public class Order {

    private OrderNo number;
    private Orderer orderer;
    private ShippingInfo shippingInfo;

    // 도메인 모델 엔티티는 도메인 기능도 함께 제공
    public void changeShippingInfo() {
        ...
    }
}
